#4강~14강
#4강


### 병행성
  - 여러 개의 프로세스 또는 쓰레드가 동시에 실행되는 시스템의 특성
  - 동시에 실행되는 여러 개의 프로세스 또는 쓰레드를 병행 프로세스라 부름
  - 하나의 CPU에서는 병행 프로세스가 인터리빙 형식으로 실행
  - ```메모리 구조에 따른 병행 프로세스의 실행(공유 메모리 구조, 분산 메모리 구조)```
  - ```병행성 문제: 공유자원 점유 문제, 동기화 문제, 통신 문제```

### 프로세스 동기화
  - ```2개 이상의 프로세스```에 대한 처리순서를 결정하는 것
  - ```동시에 사용할 수 없는 공유자원이 있는 경우``` 동기화 필요
  - 한 프로세스의 처리 결과에 따라 ```다른 프로세스의 처리가 영향을 받는 경우``` 동기화 필요

### 상호배제
  - 2개 이상의 프로세스가 동시에 ```공유자원을 액세스하는 코드 영역에 진입하지 못하도록 하는 것```
  - 2개 이상의 프로세스가 동시에 ```임계영역에 진입하지 못하도록 하는 것```

### 임계영역
  - 2개 이상의 프로세스가 동시에 ```액세스하면 안되는 공유자원을 액세스하는 코드 영역```

### 기아상태
  - 기아: 프로세스가 필요한 ```자원할당을 받지 못하고 계속적으로 대기```하게 되는 상황

### Test-and-Set
  - ```Busy waiting```을 함으로써 다른 작업이 사용할 수 있는 CPU 사이클을 낭비
  - 원자적으로 수행됨
  - ```lock 이 거짓이었다면 프로세스는 임계영역```에 들어가게 됨
  - 많은 프로세스가 임계영역에 들어가기를 원할 때 기아가 발생할 수 있음

### 세마포어
  - ```사용 가능한 자원의 수를 저장할 수 있음```
  - Dijkstra가 제안한 동기화 도구
  - 정수형 공용변수
  - 두 표준단위 연산 P와 V에 의해서만 접근됨
  - 상호배제(mutex의 초깃값1), 동기화(full의 초깃값 0, empty의 초깃값 n)
  - 상호배제(wrt의 초깃값1), 판독기우선(변수 readcount의 초깃값 0, mutex의 초깃값 1)
  - ```P(s): 검사, 감소시키려는 시도 > s := s - 1;```
  - ```V(s): 증가 > s := s + 1;```
  ```
  P(mutex); -- 감소
  S1; -- 임계영역
  V(mutex); -- 증가
  ```
  동기화 문제 해결
  ```
  프로세스 1
  ....
  S1;
  V(sync); -> wakeup
  ....

  프로세스2
  ....
  P(sync); -> block
  S2;
  ```

### 판독기/기록기
  - ```여러 개의 판독기가 동시에 공유 데이터 객체에 접근하는 것은 문제 없음```
  - 기록기가 다른 기록기 또는 판독기와 동시에 공유 데이터 객체에 접근하는 것은 문제
  - 우선순위에 따른 문제의 변형 > 제1판독기/기록기 문제(판독기 우선), 제2판독기/기록기 문제(기록기 우선)

### 공유 기억장치 기법
  - ```공유 변수가 통신에 사용 됨```
  - 프로세스 간에 공유변수를 이용하여 정보를 교환(예: 유한버퍼)
  - 고속 통신 가능
  - ```통신기능 제공의 책임: 응용 프로그래머```

### 메시지 시스템 기법
  - 메시지 교환방식으로 정보를 교환
  - ```send/receive``` 연산자
  - ```소량의 데이터 교환에 유용```
  - ```통신기능 제공의 책임: 운영체제```
  - ```통신링크: 프로세스들 사이에 메시지를 주고 받기 위한 연결통로```
  - ```직접통신: 메시지 전달 연산에 수신자나 송신자 이름을 명시```
  - ```간접통신: 메시지 전달 연산에 우편함 이름을 명시```

### 교착상태
  - 2개 이상의 프로세스가 ```서로 상대방의 작업이 끝나기만을 기다리고 있는 상태```
  - ```자원을 할당해도 안전상태가 유지되는 경우 자원을 할당해도 문제가 없음```
  - 필요조건
    - ```상호배제 조건: 프로세스들이 자원에 대한 배타적인 통제권을 요구```
    - ```점유 대기 조건: 프로세스 A가 자원 S를 할당받아 배타적으로 점유한 채로 프로세스 B가 점유 중인 자원 T가 해제되기를 기다리는 상황```
    - ```비선점 조건: 프로세스에 할당된 자원은 그 프로세스가 사용을 마치고 스스로 반환하기 전에 제거되지 않음```
    - ```환형 대기 조건: 프로세스의 자원 점유 및 점유된 자원의 요구 관계가 환형을 이루며 대기```
  - ```회피하기 위해 필요한 사전 정보```
    - 현재 할당된 자원
    - 가용상태의 자원
    - 프로세스들의 ```최대 요구량```
  - 처리 방법
    - 환형 대기 조건의 제거
    - 교착상태 회피
    - 교착상태 탐지 및 복구

### 기억장치
  - 용량에 따라 많은 순으로 ```보조기억장치 > 메모리 > 캐시기억장치 > 레지스터```
  - 접근 속도 빠른 순으로 ```레지스터 > 캐시기억장치 > 메모리 > 보조기억장치```
  - 비트당 기억장치 비용 순으로
  - 적절한 비용으로 높은 성능을 낼 수 있게 계층적으로 구성 ```레지스터 > 캐시 기억장치 > 메모리 > 보조기억장치```

### 메모리 분할
  - 여러 프로세스를 메모리에 적재하기 위하여 고안된 방법
  - 하나의 분할에 하나의 프로세스가 적재
  - 고정 분할
    - 메모리를 여러 개의 ```고정된 크기```의 영역으로 분할.
    - 문제점: ```내부 단편화``` > 프로세스의 크기가 적재된 분할 영역의 크기보다 작어서 분할 영역 내에 남게 되는 메모리는 낭비됨
  - 동적 분할
    - 메모리의 분할 경계가 고정되지 않음
    - 각 프로세스에게 ```필요한 만큼의 메모리만을 할당```
    - 문제점: ```외부 단편화``` > 메모리의 할당과 반환이 반복됨에 따라 작은 크기의 공백이 메모리 공간에 흩어져 생김
    - 외부 단편화 해결 방법
      - ```통합: 인접된 공백을 더 큰 하나의 공백으로 만듦```
      - ```집약: 메모리 내의 모든 공백을 하나로 모음```

### 가상 메모리
  - ```사상이 필요함```
  - ```앞으로 가장 오랫동안 사용되지 않을 페이지를 선택```
  - 현재 필요한 ```일부분만 메모리에 적재```
  - 프로세스가 참조하는 주소와 메모리에서 사용하는 ```주소를 분리```
  - 세그먼테이션 기법에서 하나의 세그먼트는 ```연속적인 공간에 저장```되어야 함

### 페이징 기법
  - ```블록의 크기가 동일한 페이지로 구성. 페이지의 크기는 모두 동일```
  - 요구 페이지 호출기법
    - ```실제 요구가 있을 때 메모리로 이동```
    - 옮길 페이지를 결정하는데 ```오버헤드를 최소화```
    - 메모리에 옮겨진 페이지는 모두 프로세스에 의해 ```실제로 참조```된 것임
    - 프로세스 시작 시점에는 프로세스 진행에 따라 연속적으로 페이지 부재 발생(성능 저하)
  - 예상 페이지 호출기법    
    - ```예상이 잘못된 경우 메모리 공간 낭비```
    - ```프로세스 시작 시점에 적용하면 성능이 개선됨```

### 세그먼테이션 기법
  - 블록의 크기가 서로 다른 세그멘트로 구성
  - ```사상표에 세그먼트 길이를 저장함```
  - ```세그먼트의 크기는 논리적 측면과 관련 있음```

### 최적화의 원칙
  - 앞으로 가장 오랫동안 사용되지 않을 페이지를 교체 대상으로 선택
  - ```이론적으로는 최적이나 미래를 예측할 수 없어 실현 불가능```

### 장치의 구성
  - ```장치 드라이버는 응용 프로그램의 입출력 요청을 해당 장치에 맞도록 변환함```
  - 장치제어기는 장치를 직접적으로 다루는 전자장치

### FIFO 페이지 교체기법
  - ```메모리 내에 가장 오래있었던 페이지를 교체```

### LFU(Least Frequently Used) 페이지 교체기법
  - ```참조된 횟수가 가장 적은 페이지를 교체```

### LRU(Least Recently Used) 페이지 교체기법
  - ```가장 오랫동안 사용되지 않은 페이지를 교체```
  - Belady의 이상현상이 발생하지 않음

### 워킹세트
  - ```워킹세트 W(t, w) : (t-w) 부터 t까지의 참조된 페이지의 집합```
  - 하나의 프로세스가 자주 참조하는 페이지의 집합
  - ```데닝이 제안```
  - 페이지 부재 비율을 ```감소```시키기 위한 방법
  - 프로세스가 실행됨에 따라 워킹세트의 ```크기는 변함```
  - 실행주인 프로그램의 워킹세트를 메모리에 유지(국부성)

### 입줄력 관리
  - 버퍼링
    - ```CPU의 데이터 처리 속도와 입출력장치의 데이터 전송 속도의 차이로 인한 문제를 버퍼를 통해 해결```
    - 단일 버퍼링은 하나의 버퍼를 이용
    - 순환 버퍼링은 저장과 처리가 동시에 이루어질 수 있음
    - 버퍼: 입출력 데이터 등의 정보를 전송할 때 일시적 데이터 저장 장소로 사용되는 메모리의 일부
  - 스풀링
    - 입출력 프로세스와 ```저속 입출력장치 사이```의 데이터 전송을 자기 디스크와 같은 고속 장치를 통하도록 하는 것
    - ```일종의 버퍼링```
    - 입출력 작업이 ```빨리 끝나게``` 할 수 있음
    - ```전용장치를 가상장치로 변화```시켜 줌

### 입출력 처리 유형
  - 프로그램 방법: CPU 만을 이용하여 입출력을 처리. ```폴링 이용```
    - ```폴링** 이용 (CPU가 입출력장치의 상태를 지속적으로 확인하며 원하는 상태가 될 때 까지 기다리는 것)
  - 인터럽트 방법: 인터립트를 이용하여 입출력을 처리
    - ```인터럽트```: 어떤 장치가 다른 장치의 ```작업을 잠시 중단시키고 자신의 상태를 알리는 기능```
  - DMA 방법: DMA 제어기를 이용하여 입출력을 처리
    - ```DMA```: CPU를 통하지 않고 직접 메모리에 접근

### 사이클 스틸링
  - CPU와 DMA 제어기가 동시에 메모리 액세스를 시도한 경우 CPU보다 DMA 제어기에 ```우선권을 부여```하는 것을 의미

### 디스크 스케줄링
  - ```일반적으로 가장 중요하게 고려하는 시간은 탐구시간``` > 회전지연시간, 전송시간 순
  - ```탐구시간: 자기디스크의 접근시간 구성요소 중 헤드를 움직여 지정된 트랙에 위치시키는데 걸리는 시간을 의미```
  - 디스크 접근 시간: 탐구시간 + 회전지연시간 + 전송시간
  - 디스크 접근 요구를 효율적으로 처리하는 순서를 결정하는 작업
  - ```FCFS: 먼저 도착한 요구가 먼저 서비스를 받는 방법```
    - 헤드 위치: 트랙 35
    - 디스크 트랙 요구 큐 - 20, 50, 40, 90, 25
    - ```20, 50, 40, 90, 25``` 총 이동거리 : 170
  - ```SSTF: 탐구시간이 가장 짧은 요구를 먼저 처리```
    - 헤드 위치: 트랙 35
    - 디스크 트랙 요구 큐 - 20, 50, 40, 90, 25
    - ```40, 50, 25, 20, 90``` 총 이동거리 : 115
  - ```SCAN: 가장 안쪽/바깥쪽 트랙을 왕복하며 진행방향의 가장 가까운 요구를 처리```
    - 헤드 위치: 트랙 35
    - 디스크 트랙 요구 큐 - 20, 50, 40, 90, 25
    - ```25, 20, 40, 50, 90``` 총 이동거리 : 125 (```0까지 간 뒤 40으로```)
  - ```LOOK: SCAN처럼 처리하되 진행방향의 앞쪽에 더 이상 요구가 없으면 방향을 바꿈```
    - 헤드 위치: 트랙 35
    - 디스크 트랙 요구 큐 - 20, 50, 40, 90, 25
    - ```25, 20, 40, 50, 90``` 총 이동거리 : 85
  - ```SLTF: 회전지연시간이 가장 짧은 것은 먼저 처리```(위의 방식과 다른 처리 방식)
  - N-Step SCAN, C-SCAN, LOOK, C-LOOK

### 직접접근 저장장치
  - 자기 디스크, 광 디스크, SSD

### 운영체제 보안의 기본 목표
  - ```무결성: 비인가 주체에 의한 자원의 생성, 변경, 삭제 등르로 부터 자원을 보호```
  - ```기밀성: 운영체제 자원의 부적절한 노출을 예방하고 감지```
  - ```가용성: 모든 주체는 합벅적인 경우에는 항상 객체에 접근이 가능해야 함```

### 벨-라파듈라(BLP) 모델
  - ```상위 보안 수준에서 하위 보안 수준으로``` 정보가 흐르는 것을 방지하는 것에 관심을 둠
  - ```기밀성 유지에 초점```
  - 시스템 보안을 위한 규칙 준수 규정과 주체의 객체 접근 허용 범위를 규정
  - 낮은 등급을 갖는 주체가 높은 등급을 갖는 객체에 대한 수정을 허용
  - 보안 시스템 내에서 허용되는 정보의 흐름을 설명하는 모델

### 비바(Biba) 모델
  - ```하위 보안 수준에서 상위 보안 수준으로``` 정보가 흐르는 것을 방지하는 것에 관심을 둠
  - BLP 모델에 ```불법 수정 방지를 추가로 정의```한 무결성을 중요시하는 모델
  - 낮은 등급의 주체가 높은 등급의 객체로 쓰기 접근을 금지

### 완전 연결 네트워크
  - 분산 시스템의 네트워크 구성 중 구축비용은 많이 들지만 통신 비용과 가용성 측면에서 가장 좋음

### 가용성
  - ```링크나 사이트의 고장 시 접근 가능성```
  - 가용성 높음: 완전연결, 스타형(```단, 중앙 사이트 제외```), 링형, 버스형
  - 가용성 낮음: 부분연결, 트리구조

### 통신비용
  - ```메시지를 보내는데 쓰이는 시간과 비용```
  - 많음: 부분연결, 링형
  - 낮음: 완전연결, 트리, 스타형, 버스형

### 보안정책
  - 권한부여: ```어떤 객체를 어떻게 액세스 할 수 있는가를 결정```
  - 임의적 접근제어: 개별 소유자의 ```자율적 판단```에 따라 자원의 접근권한을 다른 사용자에게 부여
  - 강제적 접근제어: 개별 객체에는 비밀등급을, 사용자에게는 허가```등급을 부여```
  - 역할 기반 접근제어: 권한은 역할과 관계가 있음. 사용자는 역할의 멤버가 됨으로써 ```권한을 배정```받음
  - 최소권한: 사용자는 특정 임무를 수행하는데 필요한 ```최소한의 제한적 권한만 할당```받아야 함
  - 감사: 컴퓨터 시스템에 중요한 사건이 발생하면 즉시 시스템의 안전한 곳에 ```자동적으로 기록```

### 메모리
  - 기준 레지스터와 한계 레지스터를 이용하여 주소의 범위를 지정하는 방법으로 보호하는 대상

### 운영체제 보안 모델
  - 참조 모니터 모델: 접근 권한을 정의한 데이터베이스를 참조하여 보안 정책을 수행
