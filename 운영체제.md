#4강~14강
#4강


##### 병행성
  - 여러 개의 프로세스 또는 쓰레드가 동시에 실행되는 시스템의 특성
  - 동시에 실행되는 여러 개의 프로세스 또는 쓰레드를 병행 프로세스라 부름
  - 하나의 CPU에서는 병행 프로세스가 인터리빙 형식으로 실행
  - <span style="color:red">메모리 구조에 따른 병행 프로세스의 실행(공유 메모리 구조, 분산 메모리 구조)</span>
  - <span style="color:red">병행성 문제: 공유자원 점유 문제, 동기화 문제, 통신 문제</span>

##### 프로세스 동기화
  - <span style="color:red">2개 이상의 프로세스</span>에 대한 처리순서를 결정하는 것
  - <span style="color:red">동시에 사용할 수 없는 공유자원이 있는 경우</span> 동기화 필요
  - 한 프로세스의 처리 결과에 따라 <span style="color:red">다른 프로세스의 처리가 영향을 받는 경우</span> 동기화 필요

##### 상호배제
  - 2개 이상의 프로세스가 동시에 <span style="color:red">공유자원을 액세스하는 코드 영역에 진입하지 못하도록 하는 것</span>
  - 2개 이상의 프로세스가 동시에 <span style="color:red">임계영역에 진입하지 못하도록 하는 것</span>

##### 임계영역
  - 2개 이상의 프로세스가 동시에 <span style="color:red">액세스하면 안되는 공유자원을 액세스하는 코드 영역</span>

##### 기아상태
  - 기아: 프로세스가 필요한 <span style="color:red">자원할당을 받지 못하고 계속적으로 대기</span>하게 되는 상황

##### Test-and-Set
  - <span style="color:red">Busy waiting</span>을 함으로써 다른 작업이 사용할 수 있는 CPU 사이클을 낭비
  - 원자적으로 수행됨
  - <span style="color:red">lock 이 거짓이었다면 프로세스는 임계영역</span>에 들어가게 됨
  - 많은 프로세스가 임계영역에 들어가기를 원할 때 기아가 발생할 수 있음

##### 세마포어
  - <span style="color:red">사용 가능한 자원의 수를 저장할 수 있음</span>
  - Dijkstra가 제안한 동기화 도구
  - 정수형 공용변수
  - 두 표준단위 연산 P와 V에 의해서만 접근됨
  - 상호배제(mutex의 초깃값1), 동기화(full의 초깃값 0, empty의 초깃값 n)
  - 상호배제(wrt의 초깃값1), 판독기우선(변수 readcount의 초깃값 0, mutex의 초깃값 1)
  - <span style="color:red">P(s): 검사, 감소시키려는 시도 > s := s - 1;</span>
  - <span style="color:red">V(s): 증가 > s := s + 1;</span>
  ```
  P(mutex); -- 감소
  S1; -- 임계영역
  V(mutex); -- 증가
  ```
  동기화 문제 해결
  ```
  프로세스 1
  ....
  S1;
  V(sync); -> wakeup
  ....

  프로세스2
  ....
  P(sync); -> block
  S2;
  ```

##### 판독기/기록기
  - <span style="color:red">여러 개의 판독기가 동시에 공유 데이터 객체에 접근하는 것은 문제 없음</span>
  - 기록기가 다른 기록기 또는 판독기와 동시에 공유 데이터 객체에 접근하는 것은 문제
  - 우선순위에 따른 문제의 변형 > 제1판독기/기록기 문제(판독기 우선), 제2판독기/기록기 문제(기록기 우선)

##### 공유 기억장치 기법
  - <span style="color:red">공유 변수가 통신에 사용 됨</span>
  - 프로세스 간에 공유변수를 이용하여 정보를 교환(예: 유한버퍼)
  - 고속 통신 가능
  - <span style="color:red">통신기능 제공의 책임: 응용 프로그래머</span>

##### 메시지 시스템 기법
  - 메시지 교환방식으로 정보를 교환
  - <span style="color:red">send/receive</span> 연산자
  - <span style="color:red">소량의 데이터 교환에 유용</span>
  - <span style="color:red">통신기능 제공의 책임: 운영체제</span>
  - <span style="color:red">통신링크: 프로세스들 사이에 메시지를 주고 받기 위한 연결통로</span>
  - <span style="color:red">직접통신: 메시지 전달 연산에 수신자나 송신자 이름을 명시</span>
  - <span style="color:red">간접통신: 메시지 전달 연산에 우편함 이름을 명시</span>

##### 교착상태
  - 2개 이상의 프로세스가 <span style="color:red">서로 상대방의 작업이 끝나기만을 기다리고 있는 상태</span>
  - <span style="color:red">자원을 할당해도 안전상태가 유지되는 경우 자원을 할당해도 문제가 없음</span>
  - 필요조건
    - <span style="color:red">상호배제 조건: 프로세스들이 자원에 대한 배타적인 통제권을 요구</span>
    - <span style="color:red">점유 대기 조건: 프로세스 A가 자원 S를 할당받아 배타적으로 점유한 채로 프로세스 B가 점유 중인 자원 T가 해제되기를 기다리는 상황</span>
    - <span style="color:red">비선점 조건: 프로세스에 할당된 자원은 그 프로세스가 사용을 마치고 스스로 반환하기 전에 제거되지 않음</span>
    - <span style="color:red">환형 대기 조건: 프로세스의 자원 점유 및 점유된 자원의 요구 관계가 환형을 이루며 대기</span>
  - <span style="color:red">회피하기 위해 필요한 사전 정보</span>
    - 현재 할당된 자원
    - 가용상태의 자원
    - 프로세스들의 <span style="color:red">최대 요구량</span>
  - 처리 방법
    - 환형 대기 조건의 제거
    - 교착상태 회피
    - 교착상태 탐지 및 복구

##### 기억장치
  - 용량에 따라 많은 순으로 <span style="color:red">보조기억장치 > 메모리 > 캐시기억장치 > 레지스터</span>
  - 접근 속도 빠른 순으로 <span style="color:red">레지스터 > 캐시기억장치 > 메모리 > 보조기억장치</span>
  - 비트당 기억장치 비용 순으로
  - 적절한 비용으로 높은 성능을 낼 수 있게 계층적으로 구성 <span style="color:red">레지스터 > 캐시 기억장치 > 메모리 > 보조기억장치</span>

##### 메모리 분할
  - 여러 프로세스를 메모리에 적재하기 위하여 고안된 방법
  - 하나의 분할에 하나의 프로세스가 적재
  - 고정 분할
    - 메모리를 여러 개의 <span style="color:red">고정된 크기</span>의 영역으로 분할.
    - 문제점: <span style="color:red">내부 단편화</span> > 프로세스의 크기가 적재된 분할 영역의 크기보다 작어서 분할 영역 내에 남게 되는 메모리는 낭비됨
  - 동적 분할
    - 메모리의 분할 경계가 고정되지 않음
    - 각 프로세스에게 <span style="color:red">필요한 만큼의 메모리만을 할당</span>
    - 문제점: <span style="color:red">외부 단편화</span> > 메모리의 할당과 반환이 반복됨에 따라 작은 크기의 공백이 메모리 공간에 흩어져 생김
    - 외부 단편화 해결 방법
      - <span style="color:red">통합: 인접된 공백을 더 큰 하나의 공백으로 만듦</span>
      - <span style="color:red">집약: 메모리 내의 모든 공백을 하나로 모음</span>

##### 가상 메모리
  - <span style="color:red">사상이 필요함</span>
  - <span style="color:red">앞으로 가장 오랫동안 사용되지 않을 페이지를 선택</span>
  - 현재 필요한 <span style="color:red">일부분만 메모리에 적재</span>
  - 프로세스가 참조하는 주소와 메모리에서 사용하는 <span style="color:red">주소를 분리</span>
  - 세그먼테이션 기법에서 하나의 세그먼트는 <span style="color:red">연속적인 공간에 저장</span>되어야 함

##### 페이징 기법
  - <span style="color:red">블록의 크기가 동일한 페이지로 구성. 페이지의 크기는 모두 동일</span>
  - 요구 페이지 호출기법
    - <span style="color:red">실제 요구가 있을 때 메모리로 이동</span>
    - 옮길 페이지를 결정하는데 <span style="color:red">오버헤드를 최소화</span>
    - 메모리에 옮겨진 페이지는 모두 프로세스에 의해 <span style="color:red">실제로 참조</span>된 것임
    - 프로세스 시작 시점에는 프로세스 진행에 따라 연속적으로 페이지 부재 발생(성능 저하)
  - 예상 페이지 호출기법    
    - <span style="color:red">예상이 잘못된 경우 메모리 공간 낭비</span>
    - <span style="color:red">프로세스 시작 시점에 적용하면 성능이 개선됨</span>

##### 세그먼테이션 기법
  - 블록의 크기가 서로 다른 세그멘트로 구성
  - <span style="color:red">사상표에 세그먼트 길이를 저장함</span>
  - <span style="color:red">세그먼트의 크기는 논리적 측면과 관련 있음</span>

##### 최적화의 원칙
  - 앞으로 가장 오랫동안 사용되지 않을 페이지를 교체 대상으로 선택
  - <span style="color:red">이론적으로는 최적이나 미래를 예측할 수 없어 실현 불가능</span>

##### 장치의 구성
  - <span style="color:red">장치 드라이버는 응용 프로그램의 입출력 요청을 해당 장치에 맞도록 변환함</span>
  - 장치제어기는 장치를 직접적으로 다루는 전자장치

##### FIFO 페이지 교체기법
  - <span style="color:red">메모리 내에 가장 오래있었던 페이지를 교체</span>

##### LFU(Least Frequently Used) 페이지 교체기법
  - <span style="color:red">참조된 횟수가 가장 적은 페이지를 교체</span>

##### LRU(Least Recently Used) 페이지 교체기법
  - <span style="color:red">가장 오랫동안 사용되지 않은 페이지를 교체</span>
  - Belady의 이상현상이 발생하지 않음

##### 워킹세트
  - <span style="color:red">워킹세트 W(t, w) : (t-w) 부터 t까지의 참조된 페이지의 집합</span>
  - 하나의 프로세스가 자주 참조하는 페이지의 집합
  - <span style="color:red">데닝이 제안</span>
  - 페이지 부재 비율을 <span style="color:red">감소</span>시키기 위한 방법
  - 프로세스가 실행됨에 따라 워킹세트의 <span style="color:red">크기는 변함</span>
  - 실행주인 프로그램의 워킹세트를 메모리에 유지(국부성)

##### 입줄력 관리
  - 버퍼링
    - <span style="color:red">CPU의 데이터 처리 속도와 입출력장치의 데이터 전송 속도의 차이로 인한 문제를 버퍼를 통해 해결</span>
    - 단일 버퍼링은 하나의 버퍼를 이용
    - 순환 버퍼링은 저장과 처리가 동시에 이루어질 수 있음
    - 버퍼: 입출력 데이터 등의 정보를 전송할 때 일시적 데이터 저장 장소로 사용되는 메모리의 일부
  - 스풀링
    - 입출력 프로세스와 <span style="color:red">저속 입출력장치 사이</span>의 데이터 전송을 자기 디스크와 같은 고속 장치를 통하도록 하는 것
    - <span style="color:red">일종의 버퍼링</span>
    - 입출력 작업이 <span style="color:red">빨리 끝나게</span> 할 수 있음
    - <span style="color:red">전용장치를 가상장치로 변화</span>시켜 줌

##### 입출력 처리 유형
  - 프로그램 방법: CPU 만을 이용하여 입출력을 처리. <span style="color:red">폴링 이용</span>
    - <span style="color:red">폴링** 이용 (CPU가 입출력장치의 상태를 지속적으로 확인하며 원하는 상태가 될 때 까지 기다리는 것)
  - 인터럽트 방법: 인터립트를 이용하여 입출력을 처리
    - <span style="color:red">인터럽트</span>: 어떤 장치가 다른 장치의 <span style="color:red">작업을 잠시 중단시키고 자신의 상태를 알리는 기능</span>
  - DMA 방법: DMA 제어기를 이용하여 입출력을 처리
    - <span style="color:red">DMA</span>: CPU를 통하지 않고 직접 메모리에 접근

##### 사이클 스틸링
  - CPU와 DMA 제어기가 동시에 메모리 액세스를 시도한 경우 CPU보다 DMA 제어기에 <span style="color:red">우선권을 부여</span>하는 것을 의미

##### 디스크 스케줄링
  - <span style="color:red">일반적으로 가장 중요하게 고려하는 시간은 탐구시간</span> > 회전지연시간, 전송시간 순
  - <span style="color:red">탐구시간: 자기디스크의 접근시간 구성요소 중 헤드를 움직여 지정된 트랙에 위치시키는데 걸리는 시간을 의미</span>
  - 디스크 접근 시간: 탐구시간 + 회전지연시간 + 전송시간
  - 디스크 접근 요구를 효율적으로 처리하는 순서를 결정하는 작업
  - <span style="color:red">FCFS: 먼저 도착한 요구가 먼저 서비스를 받는 방법</span>
    - 헤드 위치: 트랙 35
    - 디스크 트랙 요구 큐 - 20, 50, 40, 90, 25
    - <span style="color:red">20, 50, 40, 90, 25</span> 총 이동거리 : 170
  - <span style="color:red">SSTF: 탐구시간이 가장 짧은 요구를 먼저 처리</span>
    - 헤드 위치: 트랙 35
    - 디스크 트랙 요구 큐 - 20, 50, 40, 90, 25
    - <span style="color:red">40, 50, 25, 20, 90</span> 총 이동거리 : 115
  - <span style="color:red">SCAN: 가장 안쪽/바깥쪽 트랙을 왕복하며 진행방향의 가장 가까운 요구를 처리</span>
    - 헤드 위치: 트랙 35
    - 디스크 트랙 요구 큐 - 20, 50, 40, 90, 25
    - <span style="color:red">25, 20, 40, 50, 90</span> 총 이동거리 : 125 (<span style="color:red">0까지 간 뒤 40으로</span>)
  - <span style="color:red">LOOK: SCAN처럼 처리하되 진행방향의 앞쪽에 더 이상 요구가 없으면 방향을 바꿈</span>
    - 헤드 위치: 트랙 35
    - 디스크 트랙 요구 큐 - 20, 50, 40, 90, 25
    - <span style="color:red">25, 20, 40, 50, 90</span> 총 이동거리 : 85
  - <span style="color:red">SLTF: 회전지연시간이 가장 짧은 것은 먼저 처리</span>(위의 방식과 다른 처리 방식)
  - N-Step SCAN, C-SCAN, LOOK, C-LOOK

##### 직접접근 저장장치
  - 자기 디스크, 광 디스크, SSD

##### 운영체제 보안의 기본 목표
  - <span style="color:red">무결성: 비인가 주체에 의한 자원의 생성, 변경, 삭제 등르로 부터 자원을 보호</span>
  - <span style="color:red">기밀성: 운영체제 자원의 부적절한 노출을 예방하고 감지</span>
  - <span style="color:red">가용성: 모든 주체는 합벅적인 경우에는 항상 객체에 접근이 가능해야 함</span>

##### 벨-라파듈라(BLP) 모델
  - <span style="color:red">상위 보안 수준에서 하위 보안 수준으로</span> 정보가 흐르는 것을 방지하는 것에 관심을 둠
  - <span style="color:red">기밀성 유지에 초점</span>
  - 시스템 보안을 위한 규칙 준수 규정과 주체의 객체 접근 허용 범위를 규정
  - 낮은 등급을 갖는 주체가 높은 등급을 갖는 객체에 대한 수정을 허용
  - 보안 시스템 내에서 허용되는 정보의 흐름을 설명하는 모델

##### 비바(Biba) 모델
  - <span style="color:red">하위 보안 수준에서 상위 보안 수준으로</span> 정보가 흐르는 것을 방지하는 것에 관심을 둠
  - BLP 모델에 <span style="color:red">불법 수정 방지를 추가로 정의</span>한 무결성을 중요시하는 모델
  - 낮은 등급의 주체가 높은 등급의 객체로 쓰기 접근을 금지

##### 완전 연결 네트워크
  - 분산 시스템의 네트워크 구성 중 구축비용은 많이 들지만 통신 비용과 가용성 측면에서 가장 좋음

##### 가용성
  - <span style="color:red">링크나 사이트의 고장 시 접근 가능성</span>
  - 가용성 높음: 완전연결, 스타형(<span style="color:red">단, 중앙 사이트 제외</span>), 링형, 버스형
  - 가용성 낮음: 부분연결, 트리구조

##### 통신비용
  - <span style="color:red">메시지를 보내는데 쓰이는 시간과 비용</span>
  - 많음: 부분연결, 링형
  - 낮음: 완전연결, 트리, 스타형, 버스형

##### 보안정책
  - 권한부여: <span style="color:red">어떤 객체를 어떻게 액세스 할 수 있는가를 결정</span>
  - 임의적 접근제어: 개별 소유자의 <span style="color:red">자율적 판단</span>에 따라 자원의 접근권한을 다른 사용자에게 부여
  - 강제적 접근제어: 개별 객체에는 비밀등급을, 사용자에게는 허가<span style="color:red">등급을 부여</span>
  - 역할 기반 접근제어: 권한은 역할과 관계가 있음. 사용자는 역할의 멤버가 됨으로써 <span style="color:red">권한을 배정</span>받음
  - 최소권한: 사용자는 특정 임무를 수행하는데 필요한 <span style="color:red">최소한의 제한적 권한만 할당</span>받아야 함
  - 감사: 컴퓨터 시스템에 중요한 사건이 발생하면 즉시 시스템의 안전한 곳에 <span style="color:red">자동적으로 기록</span>

##### 메모리
  - 기준 레지스터와 한계 레지스터를 이용하여 주소의 범위를 지정하는 방법으로 보호하는 대상

##### 운영체제 보안 모델
  - 참조 모니터 모델: 접근 권한을 정의한 데이터베이스를 참조하여 보안 정책을 수행
