#기출문제

#### 소프트웨어 공학
  - 소프트웨어의 개발, 운영, 유지보수에 체계적이고 숙달되고 정량화된 접근 방법을 적용하는 것

#### 소프트웨어의 추적가능성
  - 유구사항으로부터 요구사항을 제안한 관련자를 파악할 수 있음
  - 요구사항을 변경할 때 영향을 받는 다른 요구사항을 파악할 수 있음
  - 요구사항으로부터 관련 설계 문서를 파악할 수 있음
  - 설계 문서로부터 관련 코드 조각을 파악할 수 있음

#### 방법론
  - 여러 방법들과 기술들이 정해진 프로세스 안에서 함께 묶인 것
  - 프로세스(what)와 방법(how)를 함께 기술하는 것

#### 프로토타이핑 방법
  - 프로젝트의 실현 가능성을 판단할 수 있다
  - 사용자의 기능적 요구사항을 파악한다
  - 송능이나 유용성 등의 품질 요구를 분명히 한다

#### 점증적 모델
  - 중요한 검증을 가장 먼저 개발한다
  - 중요한 부분이 반복적으로 테스트 되는 효과가 있음
  - 시간차를 두고 검증이 추가되면서 여러 번 릴리스됨
  - 기능적으로 분해하기 어렵거나 적당한 크기의 점증들로 나누기 어려운 문제가 발생한다

#### 폭포수 모델
  - 산출물을 통해 프로젝트의 진척사항을 관리하기 용이하다.
  - 단계별로 산출물을 체크하여 진행 상황을 명확하게 알 수 있다.

#### 애자일 방법
  - 변화를 수용하고, ```협업을 강조```하며, 제품의 ```빠른 인도```를 강조하는 반복적 방법
  - ```협업을 강조```하고 제품의 ```빠른 인도```를 강조함
  - 점증적이고 ```반복적 개발``` 방법
  - 요구사항의 변화에 대응하기 위한 ```반복적 개발``` 방법
  - 문서화보다 소프트웨어 자체에 집중함
  - 익스트림 프로그래밍(XP)
  - 짝 프로그래밍
  - 스크럼
  - 좋은 실천 기술
    - 짝 프로그래밍을 통한 비형식적 검토
    - 테스트 선행 개발
    - 리팩토링을 통한 지속적 코드 개선

#### COCOMO
  - 소프트웨어 개발 비용을 추정하기 위한 모델
  - 중급 COCOMO는 프로그램의 규모 외에 ```비용 승수```를 고려하여 노력과 비용을 추정한다.
  - 상세 COCOMO는 개발 단계와 서브시스템 별로 구분하여 노력을 추정한다.
  - 프로젝트 유형에 따라 개발기간을 다르게 계산함  

#### CPM
  - 일정 계획을 위한 알고리즘적 분석 방법

#### WBS
  - 개발 업무를 ```계층적으로 분할하여 표현```한 것

#### 소프트웨어 일정 계획을 위한 수행 작업
  - 전체 작업을 ```소작업```으로 분할
  - ```소작업```들의 진행 순서를 추정한다
  - 분할된 ```소작업```들에 대해 작업의 양을 인원-월(PM) 단위로 나타낸다

#### 제안서 포함 항목
  - WBS
  - 간트(Gantt) 차트
  - 개발 방법론

#### 확인과 검증(V&V)
  - 명세서의 검토, 설계 문서와 정적 검토와 동적 테스트를 포함하는 활동

#### 기능점수
  - AFP(조정기능점수) = UFP(미조정 기능점수) * VAF(조정계수)
  - 기능점수(FP)는 기능의 규모를 측정하기 위한 단위
  - 일반적으로 구현 기술이나 구현 언어와는 무관하다
  - 요구사항이나 설계 명세서를 사용하여 기능 점수를 추정할 수 있다.
  - 사무 정보 시스템의 규모 산정에 적합하다고 알려져 있다
  - 소프트웨어가 제공하는 기능을 계량화한 논리적 규모의 척도

#### 매트릭스 조직
  - ```프로젝트 조직과 기능별 조직의 장점을 취한 형태```
  - 개발자는 전문 기능 부서에 속하되 일정 기간 프로젝트에 소속되는 형태
  - 팀 구성원 간에 정보와 경험을 공유할 수 있으나 두 명의 상급자를 가지게 됨

#### 프로젝트 관리
  - 프로젝트 실패의 가장 흔한 이유는 일정을 맞추지 못한 것
  - 소프트웨어 기술의 발전 속도가 빨라 이전 프로젝트를 수행 한 경험을 살리기 어렵다
  - 프로젝트 관리가 필요한 이유는 예산과 일정의 제약 때문

#### CPM
  - 일정 계획을 위해 작업의 선후 관계를 고려하여 그래프를 작성
  - 임계 경로는 시작에서 종료까지의 경로 중 가장 긴 경로
  - 임계 경로 상의 작업은 일정 준수를 위해 지연이 허용되지 않는다

#### CMMI 단계적 모델(1~5)
  - 초기 상태(Initial)
  - 관리됨(Managed)
    - 기본적 프로세스를 이용하여 프로젝트가 관리됨
    - 기존 유사 성공 사례를 반복적으로 되풀이 할 수 있음
    - 개인의 역량에 의존하는 초기상태 수준을 벗어난 상태
    - 프로세스 하에서 프로젝트가 통제되는 수준
    - ```일정이나 비용과 같은 관리 프로세스가 중심```
    - 의미 있는 인증 수준으로는 최저 단계
  - 정의됨(Defined): 조직 특성에 맞는 표준 프로세스가 존재
  - 양적으로 관리됨(Quantitatively Managed): 프로젝트 활동이 정량적으로 관리되고 통제됨
  - 최적화됨(Optimizing): 지속적인 개선 활동이 정착화 됨
  - ```카네기멜론 대학```의 소프트웨어공학 연구소에서 제안
  - 조직이 가진 개발 프로세스 역량의 성숙도를 평가

#### 인스펙션
  - IBM의 패건이 소개
  - 공식 기술 검토 전이나 테스트를 수행하기 전에 설계 문서나 코드를, 동료나 전문가 팀이 검사하여 오류를 찾아내는 검토 방법
  - 결과물을 만들어 내는 과정도 검토 대상이 됨

#### 신뢰도
  - ```내재된 결함이 있더라도 고장으로 연결되지 않을 수 있음```
  - 고장의 결과가 심각하지 않으면 신뢰성이 높을 수 있다
  - 사용 환경에 따라 고장의 빈도가 달라진다
  - 가용성을 높이려면 고장의 평균 복구시간이 빨라야 한다
  - 논스톱 시스템의 신뢰도 축정할 때 전체 시간에서 가용시간의 비율을 자주 사용한다.
  - 신뢰성이 높으려면 고장이 발생해도 결과가 심각해서는 안된다.
  - 고장 빈도는 시스템의 사용 환경과 관계 있음

#### 회귀 테스트
  - 프로그램을 수정할 때, 잘못된 수정으로 인해 다른 부분에 새로운 오류가 유입될 수 있다.
  - 이전 단계에서 사용한 테스트 케이스 집합을 재사용 할 수 있다.

#### 블랙박스 테스트 방법
  - 랜덤 테스트
  - 완전 테스트
  - 동치 분할: 입력 집합을 동치 분할로 나누고, 대푯값으로 테스트를 수행함
  - 경계값 분석
  - 원인-결과 그래프: 명세서를 분석하여 원인-결과 그래프(의사결정 테이블)를 작성한 후 테스트 케이스를 개발함
  - 요구사항을 분석하여 입력값의 범위를 정하고 경계값을 분석함
  - 주어진 입력에 대한 출력 결과를 조사하여 기능을 테스트 한다

#### 화이트박스 테스트 방법
  - 기본 경로 테스트
    - 시작 노드에서 종료 노드까지의 선형 독립적인 경로를 모두 테스트 한다.
    - 이러한 경로는 루프의 반복이 허용되지 않는 경로로 새로운 노드나 에지를 포함한 경로를 말한다

#### 테스트 케이스
  - 테스트를 위한 입력과 예상 출력에 관한 명세 및 무엇을 검사할 지에 관한 설명

#### 테스트 작업
  - 요구 명세서가 있어야 한다
  - 요구사항의 내용은 테스트 작업을 통해 검증 가능해야 한다
  - 테스트 케이스를 설계할 때 예외적 입력 값을 고려해야 한다
  - 전체를 테스트 하는 것이 부품 하나를 테스트하는 것보다 중요하다
  - 테스트 케이스를 버리지 말고 재사용한다
  - 오류가 발견된 곳에서 추가적 오류가 발생할 가능성이 높다

#### 시스템 테스트 종류
  - 보안 테스트
  - 성능 테스트
  - 인수 테스트

#### 요구사항 문서 특성
  - 완전성: 시스템을 통해 일어날 수 있는 모든 가능한 시나리오를 기술
  - 일관성: 요구사항 간에 서로 모순되지 않는다
  - 명확성: 요구사항의 표현에서 모모한 부분이 없어야 함
  - 실현성: 제약 조건을 만족하면서 시스템을 구현할 수 있어야 함
  - 검증가능성: 요구사항이 만족되는지 테스트할 수 있다.

#### 기능적 요구사항
  - 개인 정보의 P_ID는 13자리 숫자의 형태로 구성된다

#### 모듈화
  - 전체를 독립적인 작은 단위들로 분할하는 것
  - 모듈 간에 느슨하게 결합되어 있는 것이 바람직하다
  - 모듈은 상호 독립적이어야 이해와 재사용이 쉽다
  - 하나의 모듈은 높은 응집력을 가지는 것이 좋다

#### 추상화
  - 복잡한 것을 간단히 요약하여 표현하는 것

#### 단계적 정제
  - 점차적으로 구체화하는 것

#### 아키텍처
  - ```설계 초기 또는 요구 명세 활동에서 작성되며 개발 과정에 큰 영향을 준다```
  - 요구공학 과정과 설계과정의 연결고리
  - ```프로젝트 참여자들 사이의 중요한 의사소통 수단```
  - 아키텍처의 결정은 비기능적 요구사항에 영향을 준다

#### 소프트웨어 아키텍처
  - 소프트웨어 시스템을 주요 기능을 제공하는 서브시스템들로 분해하고 이들 간의 관계를 정함
  - 시스템의 기능, 속성 및 제약사항 등을 적절히 반영하도록 구성 요소들을 식별하고 조직화함

#### 아키텍처 스타일
  - 같은 응용 분야에 속하는 소프트웨어 시스템은 유사한 아키텍처를 가질 수 잇다.
  - 시스템 설계 모델의 초안으로 사용될 수 있는 시스템 구성에 관한 패턴이 존재한다
  - 파이프 필터 구조: 서브시스템이 입력 데이터를 받아 처리하고 결과를 다른 서브시스템에 보내는 작업이 반복되는 형태

#### 계층형 아키텍처
  - 추상화의 성질을 잘 이용한 구조.
  - 시스템을 계층적으로 분할하며 하위 층이 제공하는 서비스를 상위층의 서브시스템이 사용하도록 구성

#### 3계층 아키텍처
  - 사용자 인터페이스/ 애플리케이션 로직/ 저장소의 3계층으로 분리하여 시스템을 구성하는 아키텍처 스타일

#### 완전 유지보수
  - ```가장 흔하게 일어나는 유형```
  - ```기능이나 성능의 개선```을 위해 필요한 변경 작업을 의미

#### 객체지향 개발
  - 시스템 설계 단계: 프로젝트의 설계 목표를 정의하고 시스템을 ```서브시스템들로 분해```하는 단계
  - 가장 먼저 수행해야 하는 것: 문제 도메인을 분석하여 다루어야 할 정보들에 관한 개념 모델을 작성한다
  - 요구사항 추출: 액터 찾기, 시나리오 찾기, 유스케이스 찾기. 유스케이스 상세화, 액터와 유스케이스들 간의 관계 찾기

#### 공통 결합
  - ```결합도가 가장 큰 경우``` 두 모듈이 전역 변수를 공유.

#### 역공학
  - 기존 프로그램으로부터 요구 명세사나 설계 문서를 복구한다
  - 전체 시스템을 분석하여 아키텍처를 파악한다
  - 프로그램으로부터 데이터 흐름도와 자료 사전을 생성한다

#### 재공학
  - 소프트웨어의 이해성과 유지보수성을 높이도록 시스템을 수정하는 것

#### 재구조화
  - 같은 추상 수준에서 코드나 문서의 형태를 바꾸는 작업
  - 프로그램의 제어구조를 분석하여 개선 하는 일

#### 소프트웨어 형상 관리
  - 항목의 식별, 버전 관리, 형상 구축, 변경 통제

#### 데이터 흐름도
  - 구조적 분석에서 사용되는 기능 관점의 시스템 모델
  - 데이터 흐름과 변환을 보여주는 네트워크 형태의 다이어그램

#### 소프트웨어 재공학
  - 레가시 시스템의 이해성을 높이고 유지보수성, 재사용성 등을 개선하기 위해 소프트웨어를 변경하는 작업

#### 레가시(legacy) 시스템
  - 과거에 개발되어 사용되고 있는 사업적으로 중요한 시스템

#### 형상 관리 활동
  - 형상 항목 식별: 형상 관리가 필요한 항목을 정하고 베이스라인을 수립
  - 형상 검사: 형상 관리 계획대로 형상 관리가 진행되고, 수정된 항목이 요구사항과 일치하는지 감사
  - 형상 상태의 보고: 형상 관리의 수행 결과를 기록하고 보고

#### 통합프로세스(UP)
  도입
    - 1주 정도의 짧은 기간에 수행
    - 시스템의 범위를 정하며, 비즈니스 사례를 파악하고 비전을 세움
  정련
    - 핵심 아키텍처를 구축하고 대부분의 요구사항을 명확히 정의
    - 높은 위험 요소를 해결하고, ```일정과 자원을 상세히 추정```
    - ```80% 정도의 유스케이스를 상세히 작성하며 전체 시스템의 15% 정도를 구현하는 단계```
  구축
    - 남아 있는 부분을 설계하고 구현하여 통합함
    - 최종적으로 고객에게 인도할 준비를 함
  전이
    - 사용자 환경으로 시스템을 옮김
    - 반복은 사용자 프드백을 받아 보수하는 작업

#### UML 다이어그램
  - 분석 단계: 클래스 다이어그램, 유스케이스 다이어그램, 시퀀스 다이어그램
  - 동적 모델: 상태머신 다이어그램, 시퀀스 다이어그램
  - ```시퀀스 다이어그램(교수(액터), 수업신천UI(경계), 수업관리모듈(제어), CS강좌:강좌(엔터티))```
    - 유스케이스를 실현하는 객체들의 협력을 나타냄
    - 메시지는 발생하는 순서에 따라 위에서 아래 방향으로 정렬하여 표시한다
    - 유스케이스 수행을 위한 객체들의 상호작용을 표현함
    - 메시지 송수신에 기초하여 객체들 간의 상호 관계를 보여줌
    - 동적 행위를 표현하는 모델로서 활용도가 높음

#### 유스케이스
  - 객체지향 기반의 요구사항 추출과 분석에서 필수적인 산물
  - 시스템의 동작에 관한 시나리오를 기술한 문서
  - 소프트웨어 시스템과 외부 환경과의 상호작용을 표현
  - 명세서 포함 내용: 참여 액터, 선행 조건과 종료 조건, 기본 이벤트 흐름과 대체 이벤트 흐름
  - 요구사항 분석
    - 사용자 관점에서 작성해야 한다
    - 어떻게(how)보다는 무엇(what)에 초점을 맞추어 작성한다
    - 분석 결과는 유스케이스 다이어그램과 유스케이스 명세이다

#### 유스케이스 다이어그램
  - 기능적 요구사항으로서의 유스케이스
  - 시스템과 상호작용하는 액터
  - 시스템 내부와 외부를 구분하는 경계
  - 유스케이스 및 이들 간의 관계를 요약적으로 표현
  - 사용자 요구사항을 구조화하고 텍스트 형식으로 기술
  - 구성 요소 중 기본 흐름은 목적을 달성하는 성공적 시나리오

#### 유스케이스 명세
  - 유스케이스 다이어그램의 부족한 부분을 보완하는 텍스트
  - 유스케이스 별로 구체적인 시나리오를 기술한 것
  - 유스케이스 이름, 참여 액터, 요약, 선행 조건 등으로 구성됨

#### 분석 과정의 입력물이 기도 한 기능 모델 :```유스케이스 명세 또는 사용자 스토리```

#### include
  - 두 유스케이스에서 중복된 부분을 별도의 유스케이스로 분리

#### extend
  - 선택적 또는 예외적 조건에서 기본 유스케이스를 확장하기 위한 것
  - 항상 수행되는 것이 아니라 특정 조건에서만 선택적으로 사용되는 시나리오를 분리하는 것
  - 확장 유스케이스의 재사용이 가능함

#### import 스테레오타입
  - yourPackage ---> myPackage +Myclass, -MyPrivateClass

#### UML 스테레오 타입
  - UML 요소의 의미를 바꾸거나 명확하게 하기 위한 방법
  - <<parallel>>와 같이 키워드를 <<>>로 감싸 표현한다
  - 스테레오 타입 대신에 특별한 아이콘을 사용하여 표현할 때도 있다

#### 파티션(또는 스윔 레인)
  - 액션의 수행 주체를 보임

#### 생명선
  - 참여 요소에서 아래쪽으로 향하는 점선
  - 상호작용의 순서를 보여주기 위한 시간 축

#### 메시지 전송
  - 화살표로 표시
  - 호출자가 메소드 실행을 요청하는 이벤트를 발생시키는 것
  - 동기화 메시지면 검은 삼각형의 화살표 머리로 표시(일반 화살표 머리는 비동기화 메시지)

#### UML 다이어그램
  - 유스케이스의 실현을 위해 객체들이 어떻게 상호작용하는가를 보여준다
  - 통신 다이어그램과 의미적으로는 동일하다고 할 수 있다.
  - 시간의 흐름과 순서에 따라 시스템이 동작하는 모습을 살펴 보기에 유용하다  

#### UML 액티비티 다이어 그램
  - 액션들의 흐름을 통해 계산 과정을 단계적으로 표현 할 수 있다
  - 비즈니스 프로세스의 작업 흐름을 표현
  - 흠름도와 유사하나 액션들의 병렬 수행이나 시간 관련 이벤트를 표현할 수 있다

#### 클래스 다이어그램
  - 클래스 명세와 클래스 간의 관계를 표현함
  - 시스템의 정적인 구조를 표현함
  - 객체지향 프로그램을 개발할 때 많이 활용됨
  - ```구성 요소: 추상 클래스, 인터페이스, 템플릿(또는 제너릭)```
  - 표기방법
    - 클래스에서 정의된 정적 속성을 표시할 때 밑줄을 재사용한다
    - 객체를 표시할 때 이름 부분에 밑줄을 사용한다
    - 인터페이스를 표시할 때 동그라미 표기를 이용할 수 있다

#### 상태 머신 다이어그램
  - 시스템의 동적인 면을 모델링하는 다이어그램
  - 단일 객체의 상태 변화를 표현할 때 사용한다
  - 실시간 싯스템이나 반응형 시스템에서 이벤트 중심의 처리 과정을 보여줄 때 사용할 수 있다
  - ```객체의 상태와 상태 전이를 표현하여 객체의 행위를 모델링한다```
  - ```단일 객체에 대한 행위를 모델링 한다```
  - 시스템이 실행되는 과정에서 특정 객체가 생성되어 소멸되기까지의 전 과정에 걸쳐 발생하는 이벤트와 이에 따른 상태 변화를 다룸

#### 배포 다이어그램
  - 시스템을 구성하는 하드웨어 형상, 소프트웨어 요소의 배치 등을 표현

#### A --|> B
  - A is a kind of B

#### 템플릿(또는 제너릭)
  - 타입 파라미터를 가지는 클래스
  - 클래스의 재사용성을 높이기 위해 클래스에서 다루어야 하는 객체의 타입을 미리 정하지 않고 파라미터로 남겨둔다

#### 포크와 조인
  - 병행 상태를 표현할 때 사용

#### Query와 StoredProc
  - 컴포넌트가 기능을 구현하고 이것을 외부에서 사용할 수 있게끔 노출한 인터페이스

#### DataSource의 제공자는 MySQLDB

#### DataSource 는 DBHelper가 필요로하는 인터페이스이다

#### Query 와 StoredPrco는 DBHelper의 제공 인터페이스이다

#### 육면체
  - 동종의 UML요소를 계층적으로 구조화 시켜 표현한다

#### 사각형
  - 소프트웨어 조각이 실제로 어떤 하드웨어에 배치되었는지를 보여줌

#### 구성집합체 연관(composition)
  - 전체와 부품의 생성과 소멸 주기가 같은 경우를 의미하는 포함 관계

#### 가드 조건(guard condition)
  - 상태 전이가 가능한지 여부를 나타내는 조건

#### 세탁기, 사용자, 인터페이스(조절 손잡이) UML로 표현
  - 세탁기 - 조절손잡이 O) - 사용자

#### 일반화와 특수화 관계
  - 클래스 다이어그램 작성 할 때 상속관계를 모델링할 수 있다.

#### 시스템과 사용작용하는 개체의 표기법: Doctor(사람모양)
#### 시스템과 상호작용하는 사람이나 외부 시스템: Doctor(사람모양), Insurance Company(사람모양)
